=begin
Стек  организован  по  пришншу  «последним  пришел,  первым  обслужен>>
(LIFO  -- last-in first-out). Традиционный пример - стопка подносов на подпружи­
ненной подставке в кафетерии, подносы кладутся сверху и сверху же снимаются.
Над стеком можно выполнять ограниченный набор операций. Как минимум,
это  операции  заталкивания  (pus/1)  и  выталкивания  (рор),  то  ест�,  помещения
в стек и извлечения из него. Обычно также предоставляется способ проверить,
пуст ли стек, и исследовать верхний эле"1ент, не извлекая его из стека. Но никогда
реализация нс позволяет получить доступ к эле",�енту в середине стека.

Стоит отмстить, что во многих алгоритмах стек применяется как основа эле­
ганпюrо  рекурсивного  решения.  Причина  станет понятна,  если  чуточку  поду­
мать.  При вызове функции или "1етода параметры заталкиваются в системный 
стек и выталкиваются из него при возврате. Таким образом, рекурсивный алго­
ритм просто подменяет явно опреде.1енный пользователем стек системным. Что 
лучше? Зависит от того, какое значение вы придаете понятности программы, ее 
эффективности и друrю, аспе.кгам.
=end


puts 'Old pwd: ' +  Dir.pwd
Dir.chdir( 'Ch._9_More_Advanced_Data_Structures/src' )
puts format( 'New pwd: ...%50s', Dir.pwd[-60,999])
puts

require_relative "main/stack.rb"

st = Stack.new
1.upto(7) { |i| st.push(i)}
1.upto(6) {st.pop; p st }
puts
st.store                        # маcсив с хранилищем недоступен



